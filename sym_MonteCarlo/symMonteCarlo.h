#ifndef _SYM_MONTE_CARLO_H
#define _SYM_MONTE_CARLO_H

#include <mpi.h>
#include <trng/yarn3.hpp>
#include <trng/uniform01_dist.hpp>
#include <trng/uniform_int_dist.hpp>

#include <itpp/itbase.h>
#include <itpp/stat/misc_stat.h>
#include "core.h"

typedef Real dP;
typedef std::complex<dP> dComplex;
typedef itpp::Vec<dP> ITdVec;
typedef itpp::Vec<dComplex> ITcVec;
typedef itpp::Vec<int> ITiVec;
typedef itpp::Vec<ITiVec> ITiVecArray;
typedef itpp::Vec<ITcVec> ITcVecArray;
typedef itpp::Vec<ITiVecArray> ITiVecArrayArray;
typedef itpp::Mat<dP> ITdMatrix;
typedef itpp::Mat<dComplex> ITcMatrix;
typedef itpp::Mat<int> ITiMatrix;
typedef itpp::Vec<ITdVec> ITdVecArray;

using std::cout;
using std::endl;



class state_storage_hubbard
{
public:
  ITiVec _up_fill_list;
  ITiVec _down_fill_list;
  ITiVec _up_emp_list;
  ITiVec _down_emp_list;
  ITiVec _state_vec;
  dComplex _amp;
};


class state_storage_tj
{
public:
  ITiVec _up_fill_list;
  ITiVec _down_fill_list;
  ITiVec _emp_list;
  ITiVec _state_vec;
  dComplex _amp;
};


ITiVec initialize_random_state_vec_hubbard(int Nsite, int Nf);
ITiVec initialize_random_state_vec_tj(int Nsite, int Nf);

dComplex quantum_amplitude(const IQMPS & psi, const ITiVec & state_vec);

dComplex symmetrized_quantum_amplitude_hubbard(const IQMPS & psi, const ITiVec & state_vec, const ITiVecArray &sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);
dComplex symmetrized_quantum_amplitude_tj(const IQMPS & psi, const ITiVec & state_vec, const ITiVecArray &sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

dP sym_mapping_fermion_sign_hubbard(const ITiVec & old_state_vec, const ITiVec & sym_site_mapping_table);
dP sym_mapping_fermion_sign_tj(const ITiVec & old_state_vec, const ITiVec & sym_site_mapping_table);

//compute symm eigval for psi
//site_mapping_table is labeling site by : 0,1,2,...N-1.
//DIFFERENT from psi labeling which is 1,2,3,...N!
dComplex symmetry_eigval_hubbard(const IQMPS & psi, const ITiVec & sym_site_mapping_table);

//compute symm eigval for psi projected into sym_sector with sym_sector_eigval (abelian symmetry generators only)
//site_mapping_table is labeling site by : 0,1,2,...N-1.
//DIFFERENT from psi labeling which is 1,2,3,...N!
dComplex symmetry_sector_eigval_hubbard(const IQMPS & psi, const ITiVec & sym_site_mapping_table, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);


dComplex symmetry_eigval_hubbard_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVec & sym_site_mapping_table);

dComplex symmetry_sector_eigval_hubbard_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVec & sym_site_mapping_table, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);


dComplex symmetry_eigval_tj_MonteCarlo(std::string desc,const IQMPS & psi, const ITiVec & sym_site_mapping_table);

dComplex symmetry_sector_eigval_tj_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVec & sym_site_mapping_table, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);




//assuming total symmetry group is generated by product, or semiproduct (basically every element is a multiplication of)
//of (the elements of) those subgroups generated by each generator.
//currently supporting one, two or three generators only.
//the first element is always identity
void generate_symmetry_group(const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table, ITiVecArray & sym_sector_group_site_mapping_table, ITcVec & sym_sector_group_eigval_table);


void generate_state_lists_using_state_vec_hubbard(state_storage_hubbard & state);
void generate_state_lists_using_state_vec_tj(state_storage_tj & state);
state_storage_hubbard initialize_random_state_vec_hubbard_rengine(const IQMPS & psi, int Nf, trng::yarn3 & _rengine);
state_storage_tj initialize_random_state_vec_tj_rengine(const IQMPS & psi, int Nf, trng::yarn3 & _rengine);
state_storage_hubbard initialize_random_state_vec_hubbard_rengine_symmetrized(const IQMPS & psi, int Nf, trng::yarn3 & _rengine, const ITiVecArray &sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);
state_storage_tj initialize_random_state_vec_tj_rengine_symmetrized(const IQMPS & psi, int Nf, trng::yarn3 & _rengine, const ITiVecArray &sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

enum SwapTypeHubbard { UP_EMP_to_EMP_UP, UP_DOWN_to_EMP_DL, DL_EMP_to_DOWN_UP, DL_DOWN_to_DOWN_DL, DOWN_EMP_to_EMP_DOWN, DOWN_UP_to_EMP_DL, DL_EMP_to_UP_DOWN, DL_UP_to_UP_DL, NONMOVE};

enum SwapTypetJ { UP_DOWN, UP_EMP, DOWN_EMP, NONMOVEtJ };

SwapTypeHubbard try_one_step_hubbard(const IQMPS & psi, state_storage_hubbard & state, trng::yarn3 & _rengine);
SwapTypetJ try_one_step_tj(const IQMPS & psi, state_storage_tj & state, trng::yarn3 & _rengine);
SwapTypeHubbard try_one_step_hubbard_symmetrized(const IQMPS & psi, state_storage_hubbard & state, trng::yarn3 & _rengine,const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);
SwapTypetJ try_one_step_tj_symmetrized(const IQMPS & psi, state_storage_tj & state, trng::yarn3 & _rengine,const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

//////////////Measurements////////////////

ITdVec SzSzcorr_tj(const IQMPS & psi, const ITiVec & state_vec, const ITiMatrix & bond_site_list, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

ITdVec SzSzcorr_hubbard(const IQMPS & psi, const ITiVec & state_vec, const ITiMatrix & bond_site_list, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

ITcVec SSS_hubbard(const IQMPS & psi, const ITiVec & state_vec, const ITiMatrix & triangle_site_list , const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

ITcVec SSS_tj(const IQMPS & psi, const ITiVec & state_vec, const ITiMatrix & triangle_site_list , const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

ITcVec pairpair_tj(const IQMPS & psi, const ITiVec & state_vec, const ITiMatrix & bond_pairs_list , const ITiVec & shared, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

dComplex sectornorm_tj(const IQMPS & psi, const ITiVec & state_vec, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

dComplex sectornorm_hubbard(const IQMPS & psi, const ITiVec & state_vec, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);

ITcVecArray symmetry_sector_measurement_tj_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);

ITcVecArray symmetry_sector_measurement_hubbard_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);


ITcVecArray symmetry_sector_measurement_fromfiles_tj_MonteCarlo(std::ifstream& inputstates, std::string desc,int nmeasure, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);

ITcVecArray symmetry_sector_measurement_fromfiles_hubbard_MonteCarlo(std::ifstream& inputstates, std::string desc,int nmeasure, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);

//MC is run unsymmetrized, overlap with sympsi is measured
dComplex norm_tj(const IQMPS & psi, const ITiVec & st, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);
ITcVecArray symmetry_norm_measurement_tj_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);
dComplex norm_hubbard(const IQMPS & psi, const ITiVec & st, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table);
ITcVecArray symmetry_norm_measurement_hubbard_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table);

//MC is run with sympsi, overlap of sym2psi and sympsi is measured
dComplex norm2sym_tj(const IQMPS & psi, const ITiVec & st, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table, const ITiVecArray & sym_sector_group_site_mapping_table2, const ITcVec & sym_sector_group_eigval_table2);
dComplex norm2sym_hubbard(const IQMPS & psi, const ITiVec & st, const ITiVecArray & sym_sector_group_site_mapping_table, const ITcVec & sym_sector_group_eigval_table, const ITiVecArray & sym_sector_group_site_mapping_table2, const ITcVec & sym_sector_group_eigval_table2);
ITcVecArray symmetry2_norm_measurement_tj_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table, const ITiVecArray & sym_sector_generator_site_mapping_table2, const ITcVec & sym_sector_generator_eigval_table2);
ITcVecArray symmetry2_norm_measurement_fromfiles_tj_MonteCarlo(std::ifstream& inputstates, std::string desc,int nmeasure, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table, const ITiVecArray & sym_sector_generator_site_mapping_table2, const ITcVec & sym_sector_generator_eigval_table2);
ITcVecArray symmetry2_norm_measurement_hubbard_MonteCarlo(std::string desc, const IQMPS & psi, const ITiVecArray & sym_sector_generator_site_mapping_table, const ITcVec & sym_sector_generator_eigval_table, const ITiVecArray & sym_sector_generator_site_mapping_table2, const ITcVec & sym_sector_generator_eigval_table2);

//Bonds for SzSz
void make_bonds(ITiMatrix & bond_site_list, int Nsite);
//Triangles for chirality
void make_triangles_8perhexagon(ITiMatrix & tri_site_list,int Nsite);
void make_triangles_allfromNNbonds(ITiMatrix & tri_site_list, int Nsite);
//Bond pairs for pair-pair correlation
void make_bond_pairs(ITiMatrix & bond_pairs_list, ITiVec & shared, int Nsite);
void make_bond_pairs_FULL(ITiMatrix & bond_pairs_list, ITiVec & shared, int Nsite);

int hopsign(const ITiVec & state, int site, int neigh);
//PBCs for snake numbering of honeycomb
int pbca1r(int i, int j, int r);
int pbca1l(int i, int r);
int pbca2(int i, int Ns);

#endif
